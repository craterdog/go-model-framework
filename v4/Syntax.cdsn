!>
................................................................................
.    Copyright (c) 2009-2024 Crater Dog Technologies.  All Rights Reserved.    .
................................................................................
.  DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.               .
.                                                                              .
.  This code is free software; you can redistribute it and/or modify it under  .
.  the terms of The MIT License (MIT), as published by the Open Source         .
.  Initiative. (See https://opensource.org/license/MIT)                        .
................................................................................
<!

!>
GO CLASS MODEL NOTATION
This document contains a formal definition of the Go Class Model Notation™
(GCMN) using Crater Dog Syntax Notation™ (CDSN):
 * https://github.com/craterdog/go-grammar-framework/blob/main/v4/cdsn/Syntax.cdsn

A language syntax consists of a set of rule definitions and regular expression
patterns.

Most terms within a rule definition can be constrained by one of the following
cardinalities:
  - term{M} - Exactly M instances of the specified term.
  - term{M..N} - M to N instances of the specified term.
  - term{M..} - M or more instances of the specified term.
  - term* - Zero or more instances of the specified term.
  - term+ - One or more instances of the specified term.
  - term? - An optional term.

The following intrinsic character types may be used within regular expression
pattern declarations:
  - ANY - Any language specific character.
  - LOWER - Any language specific lowercase character.
  - UPPER - Any language specific uppercase character.
  - DIGIT - Any language specific digit.
  - CONTROL - Any environment specific (non-printable) control character.
  - EOL - The environment specific end-of-line character.

The excluded "~" prefix within a regular expression pattern may only be applied
to a filtered set of possible characters.

RULE DEFINITIONS
The following rules are used by the parser when parsing the stream of tokens
generated by the scanner based on the expression patterns.  Each rule name
begins with an uppercase letter.  The rule definitions may specify the names of
expressions or other rules and are matched by the parser in the order listed.  A
rule definition may also be directly or indirectly recursive.  The parsing of
tokens is greedy and will match as many repeated token types as possible. The
sequence of terms within in a rule definition may be separated by spaces which
are ignored by the parser.  Newlines are also ignored unless a "newline" regular
expression pattern is defined and used in one or more rule definitions.
<!
Model: ModuleDefinition PrimitiveDefinitions InterfaceDefinitions

ModuleDefinition: Notice Header Imports?

PrimitiveDefinitions: TypeDefinitions? FunctionalDefinitions?

InterfaceDefinitions: ClassDefinitions InstanceDefinitions AspectDefinitions?

Notice: comment

Header: comment "package" name

Imports: "import" "(" Module+ ")"

Module: name path

TypeDefinitions: "// Types" Type+

Type: Declaration Abstraction Enumeration?

Declaration: comment "type" name Constraints?

Constraints: "[" Constraint AdditionalConstraint* "]"

Constraint: name Abstraction

AdditionalConstraint: "," Constraint

Abstraction: Prefix? name Suffix? Arguments?

Prefix:
  - Array
  - Map
  - Channel

Array: "[" "]"

Map: "map" "[" name "]"

Channel: "chan"

Suffix: "." name

Arguments: "[" Argument AdditionalArgument* "]"

Argument: Abstraction

AdditionalArgument: "," Argument

Enumeration: "const" "(" Value AdditionalValue* ")"

Value: name Abstraction "=" "iota"

AdditionalValue: name

FunctionalDefinitions: "// Functionals" Functional+

Functional: Declaration "func" "(" Parameter* ")" Result

Parameter: name Abstraction ","

Result:
  - None
  - Abstraction
  - Parameterized

None: newline

Parameterized: "(" Parameter+ ")"

ClassDefinitions: "// Classes" Class+

Class: Declaration "interface" "{" ClassMethods "}"

ClassMethods: ConstructorMethods ConstantMethods? FunctionMethods?

ConstructorMethods: "// Constructor" Constructor+

Constructor: name "(" Parameter* ")" Abstraction

ConstantMethods: "// Constant" Constant+

Constant: name "(" ")" Abstraction

FunctionMethods: "// Function" Function+

Function: name "(" Parameter* ")" Result

InstanceDefinitions: "// Instances" Instance+

Instance: Declaration "interface" "{" InstanceMethods "}"

InstanceMethods: PublicMethods AttributeMethods? AspectInterfaces?

PublicMethods: "// Public" Method+

Method: name "(" Parameter* ")" Result?

AttributeMethods: "// Attribute" Attribute+

Attribute: name "(" Parameter? ")" Abstraction?

AspectInterfaces: "// Aspect" Interface+

Interface: Abstraction

AspectDefinitions: "// Aspects" Aspect+

Aspect: Declaration "interface" "{" Method+ "}"

!>
EXPRESSION PATTERNS
The following regular expression patterns are used by the scanner to generate
a stream of tokens—each a match of a regular expression—that are to be processed
by the parser.  Each regular expression name begins with a lowercase letter.
Unlike rule definitions, a regular expression pattern cannot specify the name of
a rule within its pattern—but it may specify the name of another regular
expression.  Regular expression patterns cannot be recursive and the scanning of
patterns is greedy unless the pattern contains the ANY intrinsic character.  Any
spaces within a regular expression pattern are part of the regular expression
and are NOT ignored.
<!
comment: "/*" EOL (ANY | EOL)* EOL "*/" EOL  ! Chooses the shortest possible match.

delimiter: "[" | "]" | "(" | ")" | "{" | "}" | "." | "," | "="

name: (LOWER | UPPER) (LOWER | UPPER | DIGIT)* "_"?

path: '"' ANY* '"'  ! Chooses the shortest possible match.

